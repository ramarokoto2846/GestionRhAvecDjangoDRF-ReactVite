import io
import logging
import re
from datetime import datetime
from django.utils import timezone
from django.http import HttpResponse

from rest_framework import viewsets, permissions, filters, status
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.views import APIView
from django_filters.rest_framework import DjangoFilterBackend
from django.core.mail import send_mail
from django.conf import settings

# Import conditionnel pour ReportLab
try:
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import mm, inch
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet
    from reportlab.lib import colors
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False

from .models import Departement, Employe, Pointage, Conge, Evenement
from .serializers import (
    CustomUserSerializer, DepartementSerializer, EmployeSerializer,
    PointageSerializer, CongeSerializer, EvenementSerializer,
    EmployeeStatsCalculatedSerializer, GlobalStatsCalculatedSerializer
)
from .permissions import IsOwnerOrAdminForWrite

# Import de StatisticsService avec fallback
try:
    from .services.statistics_service import StatisticsService
except ImportError as e:
    class StatisticsService:
        @staticmethod
        def calculate_employee_weekly_stats(employe, date_reference=None):
            return {
                'employe': employe,
                'periode_debut': timezone.now().date(),
                'periode_fin': timezone.now().date(),
                'type_periode': 'hebdo',
                'heures_travail_total': timezone.timedelta(hours=40),
                'jours_travailles': 5,
                'moyenne_heures_quotidiennes': timezone.timedelta(hours=8),
                'pointages_reguliers': 4,
                'pointages_irreguliers': 1,
                'taux_regularite': 80.0,
                'conges_valides': 2,
                'conges_refuses': 0,
                'conges_en_attente': 1,
                'total_jours_conges': 10,
                'taux_approbation_conges': 100.0,
                'jours_ouvrables': 5
            }
        
        @staticmethod
        def calculate_employee_monthly_stats(employe, mois=None):
            return {
                'employe': employe,
                'periode_debut': timezone.now().date().replace(day=1),
                'periode_fin': timezone.now().date(),
                'type_periode': 'mensuel',
                'heures_travail_total': timezone.timedelta(hours=160),
                'jours_travailles': 20,
                'moyenne_heures_quotidiennes': timezone.timedelta(hours=8),
                'pointages_reguliers': 18,
                'pointages_irreguliers': 2,
                'taux_regularite': 90.0,
                'conges_valides': 3,
                'conges_refuses': 1,
                'conges_en_attente': 0,
                'total_jours_conges': 15,
                'taux_approbation_conges': 75.0,
                'jours_ouvrables': 22
            }
        
        @staticmethod
        def calculate_global_monthly_stats(mois=None):
            return {
                'periode': timezone.now().date().replace(day=1),
                'type_periode': 'mensuel',
                'total_employes': 150,
                'employes_actifs': 140,
                'total_departements': 8,
                'departements_actifs': 8,
                'taux_activite_global': 95.0,
                'total_pointages': 3000,
                'pointages_reguliers': 2700,
                'heures_travail_total': timezone.timedelta(hours=24000),
                'moyenne_heures_quotidiennes': timezone.timedelta(hours=8),
                'taux_presence': 92.0,
                'taux_regularite_global': 90.0,
                'total_conges': 45,
                'conges_valides': 35,
                'conges_refuses': 5,
                'conges_en_attente': 5,
                'taux_validation_conges': 87.5,
                'total_evenements': 12
            }
        
        @staticmethod
        def save_employee_stats_to_db(stats_data):
            return True

logger = logging.getLogger(__name__)


def parse_date(date_str):
    """Parse une date depuis une cha√Æne"""
    if not date_str:
        return None
    try:
        if isinstance(date_str, str):
            for fmt in ('%Y-%m-%d', '%d/%m/%Y', '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M'):
                try:
                    return datetime.strptime(date_str, fmt).date()
                except ValueError:
                    continue
            return datetime.fromisoformat(date_str.replace('Z', '+00:00')).date()
        return date_str
    except Exception:
        return None


# FONCTION D'ENVOI D'EMAIL POUR LES √âV√âNEMENTS
def send_event_notification_email(event, employes, action="creation"):
    """
    Envoie une notification email pour un √©v√©nement
    """
    try:
        subject = f"[√âv√©nement] {event.titre}"
        
        if action == "creation":
            subject = f"[Nouvel √âv√©nement] {event.titre}"
            body = f"""
            Bonjour,
            
            Un nouvel √©v√©nement a √©t√© programm√© :
            
            üìÖ {event.titre}
            üìù {event.description or 'Aucune description'}
            üóìÔ∏è Date de d√©but : {event.date_debut.strftime('%d/%m/%Y √† %H:%M')}
            üóìÔ∏è Date de fin : {event.date_fin.strftime('%d/%m/%Y √† %H:%M') if event.date_fin else 'Non d√©finie'}
            üìç Lieu : {event.lieu or 'Non sp√©cifi√©'}
            
            Cordialement,
            L'√©quipe de gestion RH
            """
        elif action == "modification":
            subject = f"[√âv√©nement Modifi√©] {event.titre}"
            body = f"""
            Bonjour,
            
            Un √©v√©nement a √©t√© modifi√© :
            
            üìÖ {event.titre}
            üìù {event.description or 'Aucune description'}
            üóìÔ∏è Date de d√©but : {event.date_debut.strftime('%d/%m/%Y √† %H:%M')}
            üóìÔ∏è Date de fin : {event.date_fin.strftime('%d/%m/%Y √† %H:%M') if event.date_fin else 'Non d√©finie'}
            üìç Lieu : {event.lieu or 'Non sp√©cifi√©'}
            
            Cordialement,
            L'√©quipe de gestion RH
            """
        elif action == "suppression":
            subject = f"[√âv√©nement Annul√©] {event.titre}"
            body = f"""
            Bonjour,
            
            L'√©v√©nement suivant a √©t√© annul√© :
            
            üìÖ {event.titre}
            üóìÔ∏è Date pr√©vue : {event.date_debut.strftime('%d/%m/%Y √† %H:%M')}
            
            Cordialement,
            L'√©quipe de gestion RH
            """
        else:
            body = f"""
            Bonjour,
            
            Information sur l'√©v√©nement :
            
            üìÖ {event.titre}
            üìù {event.description or 'Aucune description'}
            üóìÔ∏è Date de d√©but : {event.date_debut.strftime('%d/%m/%Y √† %H:%M')}
            üóìÔ∏è Date de fin : {event.date_fin.strftime('%d/%m/%Y √† %H:%M') if event.date_fin else 'Non d√©finie'}
            üìç Lieu : {event.lieu or 'Non sp√©cifi√©'}
            
            Cordialement,
            L'√©quipe de gestion RH
            """
        
        # R√©cup√©rer les emails valides des employ√©s
        destinataires = [emp.email for emp in employes if emp.email]
        
        if not destinataires:
            logger.warning("Aucun email valide trouv√© pour l'envoi de notification d'√©v√©nement")
            return False
        
        # ‚úÖ ENVOI R√âEL D'EMAIL
        logger.info(f"Envoi email √©v√©nement '{event.titre}' √† {len(destinataires)} employ√©s")
        
        # ENVOI R√âEL
        send_mail(
            subject=subject,
            message=body,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=destinataires,
            fail_silently=False,
        )
        
        return True
        
    except Exception as e:
        logger.error(f"Erreur envoi email √©v√©nement: {str(e)}")
        return False


class CurrentUserView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        serializer = CustomUserSerializer(request.user)
        return Response(serializer.data)


class RegisterViewSet(viewsets.ViewSet):
    permission_classes = [permissions.AllowAny]

    def create(self, request):
        serializer = CustomUserSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            return Response(CustomUserSerializer(user).data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class DepartementViewSet(viewsets.ModelViewSet):
    queryset = Departement.objects.all()
    serializer_class = DepartementSerializer
    permission_classes = [IsOwnerOrAdminForWrite]
    filter_backends = [filters.SearchFilter, DjangoFilterBackend, filters.OrderingFilter]
    search_fields = ['nom', 'responsable', 'localisation']
    filterset_fields = ['nom']
    ordering_fields = ['nom', 'nbr_employe']
    ordering = ['nom']

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)


class EmployeViewSet(viewsets.ModelViewSet):
    queryset = Employe.objects.select_related('departement').all()
    serializer_class = EmployeSerializer
    permission_classes = [IsOwnerOrAdminForWrite]
    filter_backends = [filters.SearchFilter, DjangoFilterBackend, filters.OrderingFilter]
    search_fields = ['nom', 'prenom', 'email', 'matricule', 'poste']
    filterset_fields = ['departement', 'statut', 'titre']
    ordering_fields = ['nom', 'prenom', 'matricule']
    ordering = ['nom', 'prenom']

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)

    @action(detail=False, methods=['get'])
    def stats(self, request):
        total_employes = Employe.objects.count()
        employes_actifs = Employe.objects.filter(statut='actif').count()
        employes_inactifs = Employe.objects.filter(statut='inactif').count()
        return Response({
            'total_employes': total_employes,
            'employes_actifs': employes_actifs,
            'employes_inactifs': employes_inactifs
        })


class PointageViewSet(viewsets.ModelViewSet):
    queryset = Pointage.objects.select_related('employe').all()
    serializer_class = PointageSerializer
    permission_classes = [IsOwnerOrAdminForWrite]
    filter_backends = [filters.SearchFilter, DjangoFilterBackend, filters.OrderingFilter]
    search_fields = ['employe__nom', 'employe__prenom', 'remarque']
    filterset_fields = ['date_pointage', 'employe']
    ordering_fields = ['date_pointage', 'heure_entree']
    ordering = ['-date_pointage', 'heure_entree']

    def create(self, request, *args, **kwargs):
        employe_id = request.data.get('employe')
        if employe_id:
            try:
                employe = Employe.objects.get(pk=employe_id)
                if employe.statut != 'actif':
                    return Response(
                        {"error": "Les employ√©s inactifs ne peuvent pas effectuer de pointage."},
                        status=status.HTTP_400_BAD_REQUEST
                    )
            except Employe.DoesNotExist:
                return Response(
                    {"error": "Employ√© non trouv√©."},
                    status=status.HTTP_404_NOT_FOUND
                )
        
        return super().create(request, *args, **kwargs)

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)

    @action(detail=False, methods=['get'])
    def stats_mensuelles(self, request):
        mois = int(request.query_params.get('mois', datetime.now().month))
        annee = int(request.query_params.get('annee', datetime.now().year))
        pointages = Pointage.objects.filter(
            date_pointage__year=annee,
            date_pointage__month=mois,
            duree_travail__isnull=False
        )
        total_heures = sum([p.duree_travail.total_seconds() for p in pointages]) / 3600
        return Response({
            'mois': mois,
            'annee': annee,
            'total_heures': total_heures,
            'nombre_pointages': pointages.count()
        })


class CongeViewSet(viewsets.ModelViewSet):
    queryset = Conge.objects.select_related('employe').all()
    serializer_class = CongeSerializer
    permission_classes = [IsOwnerOrAdminForWrite]
    filter_backends = [filters.SearchFilter, DjangoFilterBackend, filters.OrderingFilter]
    search_fields = ['employe__nom', 'employe__prenom', 'motif']
    filterset_fields = ['date_debut', 'date_fin', 'statut', 'employe']
    ordering_fields = ['date_debut', 'date_fin', 'statut']
    ordering = ['-date_demande']

    def create(self, request, *args, **kwargs):
        employe_id = request.data.get('employe')
        if employe_id:
            try:
                employe = Employe.objects.get(pk=employe_id)
                if employe.statut != 'actif':
                    return Response(
                        {"error": "Les employ√©s inactifs ne peuvent pas faire de demande de cong√©."},
                        status=status.HTTP_400_BAD_REQUEST
                    )
            except Employe.DoesNotExist:
                return Response(
                    {"error": "Employ√© non trouv√©."},
                    status=status.HTTP_404_NOT_FOUND
                )
        
        return super().create(request, *args, **kwargs)

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)

    @action(detail=True, methods=['post'])
    def valider(self, request, pk=None):
        logger.info(f"Requ√™te re√ßue pour valider le cong√© {pk} par l'utilisateur {request.user.email}")
        try:
            conge = self.get_object()
            conge.statut = 'valide'
            conge.date_decision = timezone.now()
            conge.save()
            logger.info(f"Cong√© {pk} valid√© avec succ√®s")
            return Response({
                'status': 'cong√© valid√©',
                'message': f"Un email de notification a √©t√© envoy√© √† {conge.employe.email}."
            })
        except Exception as e:
            logger.error(f"Erreur lors de la validation du cong√© {pk}: {str(e)}")
            return Response(
                {'error': f"Erreur lors de la validation du cong√©: {str(e)}"},
                status=status.HTTP_400_BAD_REQUEST
            )

    @action(detail=True, methods=['post'])
    def refuser(self, request, pk=None):
        logger.info(f"Requ√™te re√ßue pour refuser le cong√© {pk} par l'utilisateur {request.user.email}")
        try:
            conge = self.get_object()
            motif_refus = request.data.get('motif_refus')
            if not motif_refus:
                logger.error("Motif de refus non fourni")
                return Response(
                    {'error': 'La raison du refus est requise.'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            conge.statut = 'refuse'
            conge.date_decision = timezone.now()
            conge.motif_refus = motif_refus
            conge.save()
            logger.info(f"Cong√© {pk} refus√© avec succ√®s")
            return Response({
                'status': 'cong√© refus√©',
                'message': f"Un email de notification a √©t√© envoy√© √† {conge.employe.email}.",
                'motif_refus': conge.motif_refus or 'Non sp√©cifi√©e'
            })
        except Exception as e:
            logger.error(f"Erreur lors du refus du cong√© {pk}: {str(e)}")
            return Response(
                {'error': f"Erreur lors du refus du cong√©: {str(e)}"},
                status=status.HTTP_400_BAD_REQUEST
            )


class EvenementViewSet(viewsets.ModelViewSet):
    queryset = Evenement.objects.all()
    serializer_class = EvenementSerializer
    permission_classes = [IsOwnerOrAdminForWrite]
    filter_backends = [filters.SearchFilter, DjangoFilterBackend, filters.OrderingFilter]
    search_fields = ['titre', 'description', 'lieu']
    filterset_fields = ['date_debut', 'date_fin']
    ordering_fields = ['date_debut', 'date_fin']
    ordering = ['date_debut']

    def perform_create(self, serializer):
        # ‚úÖ ENVOI D'EMAIL √Ä LA CR√âATION D'UN √âV√âNEMENT
        instance = serializer.save(created_by=self.request.user)
        
        # R√©cup√©rer tous les employ√©s actifs
        employes_actifs = Employe.objects.filter(statut='actif')
        
        # Envoyer l'email de notification
        if employes_actifs.exists():
            send_event_notification_email(instance, employes_actifs, "creation")
        
        return instance

    def perform_update(self, serializer):
        # ‚úÖ ENVOI D'EMAIL √Ä LA MODIFICATION D'UN √âV√âNEMENT
        instance = serializer.save()
        
        # R√©cup√©rer tous les employ√©s actifs
        employes_actifs = Employe.objects.filter(statut='actif')
        
        # Envoyer l'email de notification
        if employes_actifs.exists():
            send_event_notification_email(instance, employes_actifs, "modification")
        
        return instance

    def perform_destroy(self, instance):
        # ‚úÖ ENVOI D'EMAIL √Ä LA SUPPRESSION D'UN √âV√âNEMENT
        employes_actifs = Employe.objects.filter(statut='actif')
        
        # Envoyer l'email de notification avant suppression
        if employes_actifs.exists():
            send_event_notification_email(instance, employes_actifs, "suppression")
        
        instance.delete()

    @action(detail=False, methods=['get'])
    def a_venir(self, request):
        evenements = Evenement.objects.filter(date_debut__gte=datetime.now())
        serializer = self.get_serializer(evenements, many=True)
        return Response(serializer.data)


class EmployeeStatisticsAPIView(APIView):
    def get(self, request, matricule=None):
        try:
            if matricule:
                employe = Employe.objects.get(matricule=matricule)
            else:
                matricule = request.GET.get('matricule')
                if not matricule:
                    return Response(
                        {"error": "Matricule requis"}, 
                        status=status.HTTP_400_BAD_REQUEST
                    )
                employe = Employe.objects.get(matricule=matricule)
            
            periode_type = request.GET.get('periode', 'mois')
            date_reference_str = request.GET.get('date')
            
            if date_reference_str:
                try:
                    if len(date_reference_str) == 7 and '-' in date_reference_str:
                        date_reference = datetime.strptime(date_reference_str + '-01', '%Y-%m-%d').date()
                    else:
                        date_reference = datetime.strptime(date_reference_str, '%Y-%m-%d').date()
                except ValueError as e:
                    date_reference = timezone.now().date()
            else:
                date_reference = timezone.now().date()
            
            if periode_type == 'semaine':
                stats = StatisticsService.calculate_employee_weekly_stats(employe, date_reference)
            else:
                stats = StatisticsService.calculate_employee_monthly_stats(employe, date_reference)
            
            save_to_db = request.GET.get('save', 'false').lower() == 'true'
            if save_to_db:
                StatisticsService.save_employee_stats_to_db(stats)
            
            serializer = EmployeeStatsCalculatedSerializer(stats)
            return Response(serializer.data)
            
        except Employe.DoesNotExist:
            return Response(
                {"error": "Employ√© non trouv√©"}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Erreur statistiques employ√©: {str(e)}")
            return Response(
                {"error": str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class GlobalStatisticsAPIView(APIView):
    def get(self, request):
        try:
            periode_type = request.GET.get('periode', 'mensuel')
            mois_str = request.GET.get('mois')
            
            if mois_str:
                try:
                    if len(mois_str) == 7 and '-' in mois_str:
                        mois = datetime.strptime(mois_str + '-01', '%Y-%m-%d').date()
                    else:
                        mois = datetime.strptime(mois_str, '%Y-%m-%d').date().replace(day=1)
                except ValueError as e:
                    mois = timezone.now().date().replace(day=1)
            else:
                mois = timezone.now().date().replace(day=1)
            
            if periode_type == 'mensuel':
                stats = StatisticsService.calculate_global_monthly_stats(mois)
            else:
                stats = StatisticsService.calculate_global_monthly_stats(mois)
                stats['type_periode'] = 'annuel'
            
            serializer = GlobalStatsCalculatedSerializer(stats)
            return Response(serializer.data)
            
        except Exception as e:
            logger.error(f"Erreur statistiques globales: {str(e)}")
            return Response(
                {"error": str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class ExportStatisticsPDFAPIView(APIView):
    def _normaliser_nom_fichier(self, nom):
        correspondances = {
            '√†': 'a', '√°': 'a', '√¢': 'a', '√£': 'a', '√§': 'a',
            '√®': 'e', '√©': 'e', '√™': 'e', '√´': 'e',
            '√¨': 'i', '√≠': 'i', '√Æ': 'i', '√Ø': 'i',
            '√≤': 'o', '√≥': 'o', '√¥': 'o', '√µ': 'o', '√∂': 'o',
            '√π': 'u', '√∫': 'u', '√ª': 'u', '√º': 'u',
            '√ß': 'c', '√±': 'n',
            '√Ä': 'A', '√Å': 'A', '√Ç': 'A', '√É': 'A', '√Ñ': 'A',
            '√à': 'E', '√â': 'E', '√ä': 'E', '√ã': 'E',
            '√å': 'I', '√ç': 'I', '√é': 'I', '√è': 'I',
            '√í': 'O', '√ì': 'O', '√î': 'O', '√ï': 'O', '√ñ': 'O',
            '√ô': 'U', '√ö': 'U', '√õ': 'U', '√ú': 'U',
            '√á': 'C', '√ë': 'N'
        }
        
        for accent, sans_accent in correspondances.items():
            nom = nom.replace(accent, sans_accent)
        
        nom = re.sub(r'[^\w\s-]', '', nom)
        nom = re.sub(r'[-\s]+', '_', nom)
        
        return nom.strip('_')
    
    def _export_simple_fallback(self, request, export_type):
        from django.http import JsonResponse
        
        return JsonResponse({
            'status': 'error',
            'message': f'Export PDF temporairement indisponible pour le type {export_type}',
            'debug': 'La g√©n√©ration PDF rencontre des probl√®mes techniques',
            'solution': 'Veuillez r√©essayer ult√©rieurement ou contacter le support'
        }, status=503)
    
    def get(self, request):
        export_type = request.GET.get('type', 'employe')
        
        try:
            if REPORTLAB_AVAILABLE:
                if export_type == 'employe':
                    return self._export_employee_pdf(request)
                elif export_type == 'global':
                    return self._export_global_pdf(request)
                else:
                    return Response(
                        {"error": "Type d'export non valide"}, 
                        status=status.HTTP_400_BAD_REQUEST
                    )
            else:
                return self._export_simple_fallback(request, export_type)
                
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration PDF: {str(e)}")
            return self._export_simple_fallback(request, export_type)
    
    def _export_employee_pdf(self, request):
        matricule = request.GET.get('matricule')
        if not matricule:
            return Response(
                {"error": "Matricule requis"}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            employe = Employe.objects.get(matricule=matricule)
        except Employe.DoesNotExist:
            return Response(
                {"error": "Employ√© non trouv√©"}, 
                status=status.HTTP_404_NOT_FOUND
            )
        
        periode_type = request.GET.get('periode', 'mois')
        date_reference_str = request.GET.get('date')
        
        try:
            if periode_type == 'semaine':
                stats = StatisticsService.calculate_employee_weekly_stats(employe, date_reference_str)
            else:
                if date_reference_str:
                    stats = StatisticsService.calculate_employee_monthly_stats(employe, date_reference_str)
                else:
                    stats = StatisticsService.calculate_employee_monthly_stats(employe)
        except Exception as e:
            logger.error(f"Erreur r√©cup√©ration stats employ√©: {str(e)}")
            return self._export_simple_fallback(request, 'employe')
        
        buffer = io.BytesIO()
        
        try:
            doc = SimpleDocTemplate(buffer, pagesize=A4)
            elements = []
            styles = getSampleStyleSheet()
            
            title = Paragraph("RAPPORT STATISTIQUES EMPLOY√â", styles['Title'])
            elements.append(title)
            elements.append(Spacer(1, 20))
            
            info_style = styles['Normal']
            info_elements = [
                Paragraph(f"<b>Employ√©:</b> {employe.nom} {employe.prenom}", info_style),
                Paragraph(f"<b>Matricule:</b> {employe.matricule}", info_style),
                Paragraph(f"<b>D√©partement:</b> {employe.departement.nom if employe.departement else 'Non assign√©'}", info_style),
                Paragraph(f"<b>Poste:</b> {employe.poste}", info_style),
                Paragraph(f"<b>P√©riode analys√©e:</b> {stats.get('periode_debut', 'N/A')} √† {stats.get('periode_fin', 'N/A')}", info_style),
                Paragraph(f"<b>Type de p√©riode:</b> {stats.get('type_periode', 'N/A')}", info_style),
            ]
            
            for element in info_elements:
                elements.append(element)
            
            elements.append(Spacer(1, 25))
            
            section_style = styles['Heading2']
            elements.append(Paragraph("üìä POINTAGES", section_style))
            elements.append(Spacer(1, 10))
            
            pointage_data = [
                ['Heures totales travaill√©es', self._format_duration(stats.get('heures_travail_total'))],
                ['Jours travaill√©s', f"{stats.get('jours_travailles', 0)} jours"],
                ['Moyenne quotidienne', self._format_duration(stats.get('moyenne_heures_quotidiennes'))],
                ['Pointages r√©guliers', f"{stats.get('pointages_reguliers', 0)}"],
                ['Pointages irr√©guliers', f"{stats.get('pointages_irreguliers', 0)}"],
                ['Taux de r√©gularit√©', f"{stats.get('taux_regularite', 0):.1f}%"],
            ]
            
            pointage_table = Table(pointage_data, colWidths=[100*mm, 60*mm])
            pointage_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E86AB')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#F0F8FF')),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#CCCCCC')),
                ('PADDING', (0, 0), (-1, -1), 6),
            ]))
            elements.append(pointage_table)
            elements.append(Spacer(1, 20))
            
            elements.append(Paragraph("üèñÔ∏è CONG√âS", section_style))
            elements.append(Spacer(1, 10))
            
            conge_data = [
                ['Cong√©s valid√©s', f"{stats.get('conges_valides', 0)}"],
                ['Cong√©s refus√©s', f"{stats.get('conges_refuses', 0)}"],
                ['Cong√©s en attente', f"{stats.get('conges_en_attente', 0)}"],
                ['Total jours de cong√©', f"{stats.get('total_jours_conges', 0)} jours"],
                ['Taux d\'approbation', f"{stats.get('taux_approbation_conges', 0):.1f}%"],
            ]
            
            conge_table = Table(conge_data, colWidths=[100*mm, 60*mm])
            conge_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#18A999')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#F0FFF4')),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#CCCCCC')),
                ('PADDING', (0, 0), (-1, -1), 6),
            ]))
            elements.append(conge_table)
            elements.append(Spacer(1, 25))
            
            footer_style = styles['Italic']
            footer = Paragraph(f"Rapport g√©n√©r√© le {timezone.now().strftime('%d/%m/%Y √† %H:%M')} - Syst√®me de Gestion RH", footer_style)
            elements.append(footer)
            
            doc.build(elements)
            buffer.seek(0)
            
            response = HttpResponse(buffer, content_type='application/pdf')
            
            nom_employe = f"{employe.nom}_{employe.prenom}"
            nom_employe_normalise = self._normaliser_nom_fichier(nom_employe)
            nom_fichier = f"statistiques_{nom_employe_normalise}_{employe.matricule}.pdf"
            
            response['Content-Disposition'] = f'attachment; filename="{nom_fichier}"'
            
            return response
            
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration PDF ReportLab: {str(e)}")
            return self._export_simple_fallback(request, 'employe')
    
    def _export_global_pdf(self, request):
        mois_str = request.GET.get('mois')
        
        stats = StatisticsService.calculate_global_monthly_stats(mois_str)
        
        buffer = io.BytesIO()
        
        try:
            doc = SimpleDocTemplate(buffer, pagesize=A4)
            elements = []
            styles = getSampleStyleSheet()
            
            title = Paragraph("RAPPORT STATISTIQUES GLOBALES", styles['Title'])
            elements.append(title)
            elements.append(Spacer(1, 20))
            
            periode_text = Paragraph(f"<b>P√©riode:</b> {stats.get('periode', 'N/A').strftime('%B %Y') if hasattr(stats.get('periode'), 'strftime') else 'N/A'}", styles['Normal'])
            elements.append(periode_text)
            elements.append(Spacer(1, 25))
            
            section_style = styles['Heading2']
            elements.append(Paragraph("üåê STATISTIQUES GLOBALES", section_style))
            elements.append(Spacer(1, 10))
            
            global_data = [
                ['Total employ√©s', f"{stats.get('total_employes', 0)}"],
                ['Employ√©s actifs', f"{stats.get('employes_actifs', 0)}"],
                ['Total d√©partements', f"{stats.get('total_departements', 0)}"],
                ['D√©partements actifs', f"{stats.get('departements_actifs', 0)}"],
                ['Taux d\'activit√© global', f"{stats.get('taux_activite_global', 0):.1f}%"],
                ['Total pointages', f"{stats.get('total_pointages', 0)}"],
                ['Pointages r√©guliers', f"{stats.get('pointages_reguliers', 0)}"],
                ['Heures totales travaill√©es', self._format_duration(stats.get('heures_travail_total'))],
                ['Moyenne quotidienne', self._format_duration(stats.get('moyenne_heures_quotidiennes'))],
                ['Taux de pr√©sence', f"{stats.get('taux_presence', 0):.1f}%"],
                ['Taux de r√©gularit√© global', f"{stats.get('taux_regularite_global', 0):.1f}%"],
                ['Cong√©s valid√©s', f"{stats.get('conges_valides', 0)}"],
                ['Taux validation cong√©s', f"{stats.get('taux_validation_conges', 0):.1f}%"],
                ['√âv√©nements organis√©s', f"{stats.get('total_evenements', 0)}"],
            ]
            
            global_table = Table(global_data, colWidths=[80*mm, 80*mm])
            global_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4A4A4A')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#F8F9FA')),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#CCCCCC')),
                ('PADDING', (0, 0), (-1, -1), 6),
            ]))
            elements.append(global_table)
            
            elements.append(Spacer(1, 25))
            footer = Paragraph(f"Rapport g√©n√©r√© le {timezone.now().strftime('%d/%m/%Y √† %H:%M')} - Syst√®me de Gestion RH", styles['Italic'])
            elements.append(footer)
            
            doc.build(elements)
            buffer.seek(0)
            
            response = HttpResponse(buffer, content_type='application/pdf')
            
            nom_fichier = f"statistiques_globales_{timezone.now().strftime('%Y%m%d')}.pdf"
            
            response['Content-Disposition'] = f'attachment; filename="{nom_fichier}"'
            
            return response
            
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration PDF global: {str(e)}")
            return self._export_simple_fallback(request, 'global')
    
    def _format_duration(self, duration):
        if not duration:
            return "0h 00min"
        
        try:
            if hasattr(duration, 'total_seconds'):
                total_seconds = duration.total_seconds()
            else:
                total_seconds = float(duration)
            
            hours = int(total_seconds // 3600)
            minutes = int((total_seconds % 3600) // 60)
            return f"{hours}h {minutes:02d}min"
        except:
            return "0h 00min"