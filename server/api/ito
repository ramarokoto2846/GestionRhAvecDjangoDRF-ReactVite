# class Conge(models.Model):
#     STATUT_VALIDE = [
#         ('en_attente', 'En attente'),
#         ('valide', 'Validé'),
#         ('refuse', 'Refusé')
#     ]

#     id_conge = models.CharField(max_length=10, primary_key=True)
#     employe = models.ForeignKey(Employe, on_delete=models.CASCADE, related_name="conges")
#     date_debut = models.DateField()
#     date_fin = models.DateField()
#     nbr_jours = models.IntegerField(editable=False)
#     motif = models.TextField()
#     statut = models.CharField(max_length=20, choices=STATUT_VALIDE, default='en_attente')
#     date_demande = models.DateTimeField(auto_now_add=True)
#     date_decision = models.DateTimeField(null=True, blank=True)

#     def clean(self):
#         if self.date_fin < self.date_debut:
#             raise ValidationError("La date de fin doit être après la date de début")
        
#         # Vérifier les chevauchements de congés
#         overlapping_conges = Conge.objects.filter(
#             employe=self.employe,
#             date_debut__lte=self.date_fin,
#             date_fin__gte=self.date_debut
#         ).exclude(id_conge=self.id_conge)
        
#         if overlapping_conges.exists():
#             raise ValidationError("Cet employé a déjà un congé sur cette période.")
        
#         super().clean()

#     def save(self, *args, **kwargs):
#         delta = self.date_fin - self.date_debut
#         self.nbr_jours = delta.days + 1
        
#         # Mettre à jour la date de décision si le statut change
#         if self.statut != 'en_attente' and not self.date_decision:
#             self.date_decision = datetime.now()
            
#         super().save(*args, **kwargs)

#     def __str__(self):
#         return f"Congé {self.id_conge} - {self.employe} ({self.statut})"
    



# class CongeSerializer(serializers.ModelSerializer):
#     nbr_jours = serializers.IntegerField(read_only=True)
#     employe_nom = serializers.CharField(source='employe.nom_complet', read_only=True)

#     class Meta:
#         model = Conge
#         fields = '__all__'
#         read_only_fields = ['date_demande', 'date_decision']

#     def validate(self, data):
#         if data['date_fin'] < data['date_debut']:
#             raise serializers.ValidationError("La date de fin doit être après la date de début")
#         return data
    


# class CongeViewSet(viewsets.ModelViewSet):
#     queryset = Conge.objects.select_related('employe').all()
#     serializer_class = CongeSerializer
#     permission_classes = [permissions.IsAuthenticated]
#     filter_backends = [filters.SearchFilter, DjangoFilterBackend, filters.OrderingFilter]
#     search_fields = ['employe__nom', 'employe__prenom', 'motif']
#     filterset_fields = ['date_debut', 'date_fin', 'statut', 'employe']
#     ordering_fields = ['date_debut', 'date_fin', 'statut']
#     ordering = ['-date_demande']

#     @action(detail=True, methods=['post'])
#     def valider(self, request, pk=None):
#         conge = self.get_object()
#         conge.statut = 'valide'
#         conge.date_decision = datetime.now()
#         conge.save()
#         return Response({'status': 'congé validé'})

#     @action(detail=True, methods=['post'])
#     def refuser(self, request, pk=None):
#         conge = self.get_object()
#         conge.statut = 'refuse'
#         conge.date_decision = datetime.now()
#         conge.save()
#         return Response({'status': 'congé refusé'})
    




# const congesCrud = createCrudFunctions("conges", "id_conge");
# export const getConges = congesCrud.getAll;
# export const getConge = congesCrud.getOne;
# export const createConge = congesCrud.create;
# export const updateConge = congesCrud.update;
# export const deleteConge = congesCrud.deleteOne;

# // Valider un congé
# export const validerConge = async (id) => {
#   try {
#     const response = await axios.post(`${BASE_URL}/conges/${id}/valider/`, {}, {
#       headers: getAuthHeader(),
#     });
#     return response.data;
#      // Retourne { status: 'congé validé', message: 'Un email a été envoyé...' }
#   } catch (error) {
#     handleError(error, "Erreur lors de la validation du congé.");
#   }
# };

# // Refuser un congé
# export const refuserConge = async (id) => {
#   try {
#     const response = await axios.post(`${BASE_URL}/conges/${id}/refuser/`, {}, {
#       headers: getAuthHeader(),
#     });
#     return response.data; // Retourne { status: 'congé refusé', message: 'Un email a été envoyé...' }
#   } catch (error) {
#     handleError(error, "Erreur lors du refus du congé.");
#   }
# };