class Conge(models.Model):
    STATUT_VALIDE = [
        ('en_attente', 'En attente'),
        ('valide', 'Validé'),
        ('refuse', 'Refusé')
    ]

    id_conge = models.CharField(max_length=10, primary_key=True)
    employe = models.ForeignKey('Employe', on_delete=models.CASCADE, related_name="conges")
    date_debut = models.DateField()
    date_fin = models.DateField()
    nbr_jours = models.IntegerField(editable=False)
    motif = models.TextField()
    motif_refus = models.TextField(null=True, blank=True)  # Raison du refus
    statut = models.CharField(max_length=20, choices=STATUT_VALIDE, default='en_attente')
    date_demande = models.DateTimeField(auto_now_add=True)
    date_decision = models.DateTimeField(null=True, blank=True)

    def clean(self):
        if self.date_fin < self.date_debut:
            raise ValidationError("La date de fin doit être après la date de début")
        
        # Vérifier chevauchement
        overlapping_conges = Conge.objects.filter(
            employe=self.employe,
            date_debut__lte=self.date_fin,
            date_fin__gte=self.date_debut
        ).exclude(id_conge=self.id_conge)
        
        if overlapping_conges.exists():
            raise ValidationError("Cet employé a déjà un congé sur cette période.")
        
        super().clean()

    def save(self, *args, **kwargs):
        # Calcul du nombre de jours
        delta = self.date_fin - self.date_debut
        self.nbr_jours = delta.days + 1

        old_status = None
        is_update = False

        # Vérifie si l'objet existe déjà en base
        if self.pk and Conge.objects.filter(pk=self.pk).exists():
            old_instance = Conge.objects.get(pk=self.pk)
            old_status = old_instance.statut
            is_update = True

        # Mettre à jour la date_decision si le statut passe à "valide" ou "refuse"
        if self.statut in ['valide', 'refuse'] and not self.date_decision:
            from django.utils import timezone
            self.date_decision = timezone.now()

        super().save(*args, **kwargs)

        # Notification si nouveau congé ou changement de statut
        if not is_update or (is_update and old_status != self.statut):
            self._send_notification_email()

    def _send_notification_email(self):
        """Envoyer une notification par email à l'employé en fonction du statut."""
        subject = f"Statut de votre demande de congé #{self.id_conge}"

        if self.statut == 'en_attente':
            message = (
                f"Bonjour {self.employe.nom} {self.employe.prenom},\n\n"
                f"Votre demande de congé (ID: {self.id_conge}) du {self.date_debut} au {self.date_fin} "
                f"a été soumise avec succès et est en attente de validation.\n"
                f"Motif : {self.motif}\n\n"
                f"Vous serez informé(e) de la décision finale.\n\n"
                f"Cordialement,\nL'équipe RH"
            )
        elif self.statut == 'valide':
            message = (
                f"Bonjour {self.employe.nom} {self.employe.prenom},\n\n"
                f"Nous avons le plaisir de vous informer que votre demande de congé (ID: {self.id_conge}) "
                f"du {self.date_debut} au {self.date_fin} a été validée.\n"
                f"Motif : {self.motif}\n"
                f"Nombre de jours : {self.nbr_jours}\n\n"
                f"Cordialement,\nL'équipe RH"
            )
        elif self.statut == 'refuse':
            message = (
                f"Bonjour {self.employe.nom} {self.employe.prenom},\n\n"
                f"Nous sommes désolés de vous informer que votre demande de congé (ID: {self.id_conge}) "
                f"du {self.date_debut} au {self.date_fin} a été refusée.\n"
                f"Motif : {self.motif}\n"
                f"Raison du refus : {self.motif_refus or 'Non spécifiée'}\n"
                f"Pour plus d'informations, veuillez contacter le service RH.\n\n"
                f"Cordialement,\nL'équipe RH"
            )

        try:
            from django.core.mail import send_mail
            from django.conf import settings

            send_mail(
                subject=subject,
                message=message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[self.employe.email],
                fail_silently=False,
            )
        except Exception as e:
            print(f"Erreur lors de l'envoi de l'email pour le congé {self.id_conge}: {str(e)}")

    def __str__(self):
        return f"Congé {self.id_conge} - {self.employe} ({self.statut})"


class CongeSerializer(serializers.ModelSerializer):
    nbr_jours = serializers.IntegerField(read_only=True)
    employe_nom = serializers.CharField(source='employe.nom_complet', read_only=True)

    class Meta:
        model = Conge
        fields = '__all__'
        read_only_fields = ['date_demande', 'date_decision', 'nbr_jours', 'employe_nom']

    def validate(self, data):
        if data['date_fin'] < data['date_debut']:
            raise serializers.ValidationError("La date de fin doit être après la date de début")
        return data


class CongeViewSet(viewsets.ModelViewSet):
    queryset = Conge.objects.select_related('employe').all()
    serializer_class = CongeSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [filters.SearchFilter, DjangoFilterBackend, filters.OrderingFilter]
    search_fields = ['employe__nom', 'employe__prenom', 'motif']
    filterset_fields = ['date_debut', 'date_fin', 'statut', 'employe']
    ordering_fields = ['date_debut', 'date_fin', 'statut']
    ordering = ['-date_demande']

    @action(detail=True, methods=['post'])
    def valider(self, request, pk=None):
        conge = self.get_object()
        conge.statut = 'valide'
        conge.date_decision = datetime.now()
        conge.save()
        return Response({
            'status': 'congé validé',
            'message': f"Un email de notification a été envoyé à {conge.employe.email}."
        })

    @action(detail=True, methods=['post'])
    def refuser(self, request, pk=None):
        conge = self.get_object()
        conge.statut = 'refuse'
        conge.date_decision = datetime.now()
        # Capture motif_refus from request body, if provided
        conge.motif_refus = request.data.get('motif_refus', '')
        conge.save()
        return Response({
            'status': 'congé refusé',
            'message': f"Un email de notification a été envoyé à {conge.employe.email}.",
            'motif_refus': conge.motif_refus or 'Non spécifiée'
        })
    


et voila l api.js
import axios from "axios";

const BASE_URL = "http://localhost:8000/api";

// ========================
// UTILITAIRES
// ========================

// Obtenir l'en-tête d'authentification
const getAuthHeader = () => {
  const token = localStorage.getItem("access_token");
  if (!token) {
    throw new Error("Aucun token d'authentification trouvé. Veuillez vous connecter.");
  }
  return { Authorization: `Bearer ${token}` };
};

// Gestion générique des erreurs
const handleError = (error, defaultMessage) => {
  let errorMessage = defaultMessage;
  if (error.response?.data) {
    const data = error.response.data;
    if (typeof data === "string") {
      errorMessage = data;
    } else if (data.detail) {
      errorMessage = data.detail;
    } else if (data.non_field_errors) {
      errorMessage = data.non_field_errors[0];
    } else {
      const fieldErrors = Object.values(data).flat().join(", ");
      if (fieldErrors) errorMessage = fieldErrors;
    }
  } else if (error.message) {
    errorMessage = error.message;
  }
  console.error("Erreur API:", error.response?.data || error.message);
  throw new Error(errorMessage);
};

// Extraction des données (compatibilité DRF pagination)
const extractData = (responseData) => {
  if (Array.isArray(responseData)) {
    return responseData;
  } else if (responseData.results && Array.isArray(responseData.results)) {
    return responseData.results;
  } else {
    console.warn("Structure de données inattendue, retourne array vide");
    return [];
  }
};

// ========================
// AUTHENTIFICATION
// ========================

// Connexion
export const login = async (email, password) => {
  try {
    const response = await axios.post(`${BASE_URL}/token/`, { email, password });
    return response.data;
  } catch (error) {
    handleError(error, "Erreur lors de la connexion.");
  }
};

// Rafraîchir le token
export const refreshToken = async (refreshToken) => {
  try {
    const response = await axios.post(`${BASE_URL}/token/refresh/`, { refresh: refreshToken });
    return response.data;
  } catch (error) {
    handleError(error, "Erreur lors du rafraîchissement du token.");
  }
};

// Récupérer l'utilisateur courant
export const getCurrentUser = async () => {
  try {
    const response = await axios.get(`${BASE_URL}/users/me/`, { headers: getAuthHeader() });
    return response.data;
  } catch (error) {
    handleError(error, "Erreur lors de la récupération de l'utilisateur.");
  }
};

// Inscription
export const register = async (userData) => {
  try {
    const response = await axios.post(`${BASE_URL}/register/`, userData);
    return response.data;
  } catch (error) {
    handleError(error, "Erreur lors de l'inscription.");
  }
};

// ========================
// CRUD GÉNÉRIQUE
// ========================

const createCrudFunctions = (endpoint, idField) => {
  return {
    getAll: async (params = {}) => {
      try {
        const response = await axios.get(`${BASE_URL}/${endpoint}/`, {
          headers: getAuthHeader(),
          params,
        });
        return extractData(response.data);
      } catch (error) {
        handleError(error, `Erreur lors de la récupération des ${endpoint}.`);
      }
    },
    getOne: async (id) => {
      try {
        const response = await axios.get(`${BASE_URL}/${endpoint}/${id}/`, {
          headers: getAuthHeader(),
        });
        return response.data;
      } catch (error) {
        handleError(error, `Erreur lors de la récupération de ${endpoint.slice(0, -1)} avec ID ${id}.`);
      }
    },
    create: async (data) => {
      try {
        const response = await axios.post(`${BASE_URL}/${endpoint}/`, data, {
          headers: getAuthHeader(),
        });
        return response.data;
      } catch (error) {
        handleError(error, `Erreur lors de la création de ${endpoint.slice(0, -1)}.`);
      }
    },
    update: async (id, data) => {
      try {
        const response = await axios.put(`${BASE_URL}/${endpoint}/${id}/`, data, {
          headers: getAuthHeader(),
        });
        return response.data;
      } catch (error) {
        handleError(error, `Erreur lors de la mise à jour de ${endpoint.slice(0, -1)} avec ID ${id}.`);
      }
    },
    deleteOne: async (id) => {
      try {
        const response = await axios.delete(`${BASE_URL}/${endpoint}/${id}/`, {
          headers: getAuthHeader(),
        });
        return response.data;
      } catch (error) {
        handleError(error, `Erreur lors de la suppression de ${endpoint.slice(0, -1)} avec ID ${id}.`);
      }
    },
  };
};

// ========================
// DÉPARTEMENTS
// ========================
const departementsCrud = createCrudFunctions("departements", "id_departement");
export const getDepartements = departementsCrud.getAll;
export const getDepartement = departementsCrud.getOne;
export const createDepartement = departementsCrud.create;
export const updateDepartement = departementsCrud.update;
export const deleteDepartement = departementsCrud.deleteOne;

// ========================
// EMPLOYÉS
// ========================
const employesCrud = createCrudFunctions("employes", "matricule");
export const getEmployes = employesCrud.getAll;
export const getEmploye = employesCrud.getOne;
export const createEmploye = employesCrud.create;
export const updateEmploye = employesCrud.update;
export const deleteEmploye = employesCrud.deleteOne;

// Statistiques des employés
export const getEmployesStats = async () => {
  try {
    const response = await axios.get(`${BASE_URL}/employes/stats/`, {
      headers: getAuthHeader(),
    });
    return response.data;
  } catch (error) {
    handleError(error, "Erreur lors de la récupération des statistiques des employés.");
  }
};

// ========================
// POINTAGES
// ========================
const pointagesCrud = createCrudFunctions("pointages", "id_pointage");
export const getPointages = pointagesCrud.getAll;
export const getPointage = pointagesCrud.getOne;
export const createPointage = pointagesCrud.create;
export const updatePointage = pointagesCrud.update;
export const deletePointage = pointagesCrud.deleteOne;

// Statistiques mensuelles des pointages
export const getPointagesStatsMensuelles = async (mois, annee) => {
  try {
    const response = await axios.get(`${BASE_URL}/pointages/stats_mensuelles/`, {
      headers: getAuthHeader(),
      params: { mois, annee },
    });
    return response.data;
  } catch (error) {
    console.error("Erreur lors de la récupération des statistiques mensuelles :", error.response || error.message);
    handleError(error, "Erreur lors de la récupération des statistiques mensuelles des pointages.");
  }
};

// ========================
// ABSENCES
// ========================
const absencesCrud = createCrudFunctions("absences", "id_absence");
export const getAbsences = absencesCrud.getAll;
export const getAbsence = absencesCrud.getOne;
export const createAbsence = absencesCrud.create;
export const updateAbsence = absencesCrud.update;
export const deleteAbsence = absencesCrud.deleteOne;

// ========================
// CONGÉS
// ========================
const congesCrud = createCrudFunctions("conges", "id_conge");
export const getConges = congesCrud.getAll;
export const getConge = congesCrud.getOne;
export const createConge = congesCrud.create;
export const updateConge = congesCrud.update;
export const deleteConge = congesCrud.deleteOne;

// Valider un congé
export const validerConge = async (id) => {
  try {
    const response = await axios.post(`${BASE_URL}/conges/${id}/valider/`, {}, {
      headers: getAuthHeader(),
    });
    return response.data;
     // Retourne { status: 'congé validé', message: 'Un email a été envoyé...' }
  } catch (error) {
    handleError(error, "Erreur lors de la validation du congé.");
  }
};

// Refuser un congé
export const refuserConge = async (id) => {
  try {
    const response = await axios.post(`${BASE_URL}/conges/${id}/refuser/`, {}, {
      headers: getAuthHeader(),
    });
    return response.data; // Retourne { status: 'congé refusé', message: 'Un email a été envoyé...' }
  } catch (error) {
    handleError(error, "Erreur lors du refus du congé.");
  }
};

// ========================
// ÉVÉNEMENTS
// ========================
const evenementsCrud = createCrudFunctions("evenements", "id_evenement");
export const getEvenements = evenementsCrud.getAll;
export const getEvenement = evenementsCrud.getOne;
export const createEvenement = evenementsCrud.create;
export const updateEvenement = evenementsCrud.update;
export const deleteEvenement = evenementsCrud.deleteOne;

// Événements à venir
export const getEvenementsAVenir = async () => {
  try {
    const response = await axios.get(`${BASE_URL}/evenements/a_venir/`, {
      headers: getAuthHeader(),
    });
    return extractData(response.data);
  } catch (error) {
    handleError(error, "Erreur lors de la récupération des événements à venir.");
  }
};

// ========================
// EXPORT PAR DÉFAUT
// ========================
export default {
  login,
  refreshToken,
  getCurrentUser,
  register,

  // Départements
  getDepartements,
  getDepartement,
  createDepartement,
  updateDepartement,
  deleteDepartement,

  // Employés
  getEmployes,
  getEmploye,
  createEmploye,
  updateEmploye,
  deleteEmploye,
  getEmployesStats,

  // Pointages
  getPointages,
  getPointage,
  createPointage,
  updatePointage,
  deletePointage,
  getPointagesStatsMensuelles,

  // Absences
  getAbsences,
  getAbsence,
  createAbsence,
  updateAbsence,
  deleteAbsence,

  // Congés
  getConges,
  getConge,
  createConge,
  updateConge,
  deleteConge,
  validerConge,
  refuserConge,

  // Événements
  getEvenements,
  getEvenement,
  createEvenement,
  updateEvenement,
  deleteEvenement,
  getEvenementsAVenir,
};
